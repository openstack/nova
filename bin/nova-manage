#!/usr/bin/env python
# vim: tabstop=4 shiftwidth=4 softtabstop=4

# Copyright 2010 United States Government as represented by the
# Administrator of the National Aeronautics and Space Administration.
# All Rights Reserved.
#
#    Licensed under the Apache License, Version 2.0 (the "License"); you may
#    not use this file except in compliance with the License. You may obtain
#    a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#    License for the specific language governing permissions and limitations
#    under the License.

# Interactive shell based on Django:
#
# Copyright (c) 2005, the Lawrence Journal-World
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#     1. Redistributions of source code must retain the above copyright notice,
#        this list of conditions and the following disclaimer.
#
#     2. Redistributions in binary form must reproduce the above copyright
#        notice, this list of conditions and the following disclaimer in the
#        documentation and/or other materials provided with the distribution.
#
#     3. Neither the name of Django nor the names of its contributors may be
#        used to endorse or promote products derived from this software without
#        specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


"""
  CLI interface for nova management.
"""

import datetime
import gettext
import glob
import json
import os
import sys
import time

import IPy

# If ../nova/__init__.py exists, add ../ to Python search path, so that
# it will override what happens to be installed in /usr/(local/)lib/python...
POSSIBLE_TOPDIR = os.path.normpath(os.path.join(os.path.abspath(sys.argv[0]),
                                   os.pardir,
                                   os.pardir))
if os.path.exists(os.path.join(POSSIBLE_TOPDIR, 'nova', '__init__.py')):
    sys.path.insert(0, POSSIBLE_TOPDIR)

gettext.install('nova', unicode=1)

from nova import context
from nova import crypto
from nova import db
from nova import exception
from nova import flags
from nova import log as logging
from nova import quota
from nova import rpc
from nova import utils
from nova import version
from nova.api.ec2 import ec2utils
from nova.auth import manager
from nova.cloudpipe import pipelib
from nova.compute import instance_types
from nova.db import migration

FLAGS = flags.FLAGS
flags.DECLARE('fixed_range', 'nova.network.manager')
flags.DECLARE('num_networks', 'nova.network.manager')
flags.DECLARE('network_size', 'nova.network.manager')
flags.DECLARE('vlan_start', 'nova.network.manager')
flags.DECLARE('vpn_start', 'nova.network.manager')
flags.DECLARE('fixed_range_v6', 'nova.network.manager')
flags.DECLARE('images_path', 'nova.image.local')
flags.DECLARE('libvirt_type', 'nova.virt.libvirt_conn')
flags.DEFINE_flag(flags.HelpFlag())
flags.DEFINE_flag(flags.HelpshortFlag())
flags.DEFINE_flag(flags.HelpXMLFlag())


def param2id(object_id):
    """Helper function to convert various id types to internal id.
    args: [object_id], e.g. 'vol-0000000a' or 'volume-0000000a' or '10'
    """
    if '-' in object_id:
        return ec2utils.ec2_id_to_id(object_id)
    else:
        return int(object_id)


class VpnCommands(object):
    """Class for managing VPNs."""

    def __init__(self):
        self.manager = manager.AuthManager()
        self.pipe = pipelib.CloudPipe()

    def list(self, project=None):
        """Print a listing of the VPN data for one or all projects.

        args: [project=all]"""
        print "%-12s\t" % 'project',
        print "%-20s\t" % 'ip:port',
        print "%-20s\t" % 'private_ip',
        print "%s" % 'state'
        if project:
            projects = [self.manager.get_project(project)]
        else:
            projects = self.manager.get_projects()
            # NOTE(vish): This hits the database a lot.  We could optimize
            #             by getting all networks in one query and all vpns
            #             in aother query, then doing lookups by project
        for project in projects:
            print "%-12s\t" % project.name,
            ipport = "%s:%s" % (project.vpn_ip, project.vpn_port)
            print "%-20s\t" % ipport,
            ctxt = context.get_admin_context()
            vpn = db.instance_get_project_vpn(ctxt, project.id)
            if vpn:
                address = None
                state = 'down'
                if vpn.get('fixed_ip', None):
                    address = vpn['fixed_ip']['address']
                if project.vpn_ip and utils.vpn_ping(project.vpn_ip,
                                                     project.vpn_port):
                    state = 'up'
                print address,
                print vpn['host'],
                print ec2utils.id_to_ec2_id(vpn['id']),
                print vpn['state_description'],
                print state
            else:
                print None

    def spawn(self):
        """Run all VPNs."""
        for p in reversed(self.manager.get_projects()):
            if not self._vpn_for(p.id):
                print 'spawning %s' % p.id
                self.pipe.launch_vpn_instance(p.id)
                time.sleep(10)

    def run(self, project_id):
        """Start the VPN for a given project."""
        self.pipe.launch_vpn_instance(project_id)

    def change(self, project_id, ip, port):
        """Change the ip and port for a vpn.

        args: project, ip, port"""
        project = self.manager.get_project(project_id)
        if not project:
            print 'No project %s' % (project_id)
            return
        admin = context.get_admin_context()
        network_ref = db.project_get_network(admin, project_id)
        db.network_update(admin,
                          network_ref['id'],
                          {'vpn_public_address': ip,
                           'vpn_public_port': int(port)})


class ShellCommands(object):
    def bpython(self):
        """Runs a bpython shell.

        Falls back to Ipython/python shell if unavailable"""
        self.run('bpython')

    def ipython(self):
        """Runs an Ipython shell.

        Falls back to Python shell if unavailable"""
        self.run('ipython')

    def python(self):
        """Runs a python shell.

        Falls back to Python shell if unavailable"""
        self.run('python')

    def run(self, shell=None):
        """Runs a Python interactive interpreter.

        args: [shell=bpython]"""
        if not shell:
            shell = 'bpython'

        if shell == 'bpython':
            try:
                import bpython
                bpython.embed()
            except ImportError:
                shell = 'ipython'
        if shell == 'ipython':
            try:
                import IPython
                # Explicitly pass an empty list as arguments, because
                # otherwise IPython would use sys.argv from this script.
                shell = IPython.Shell.IPShell(argv=[])
                shell.mainloop()
            except ImportError:
                shell = 'python'

        if shell == 'python':
            import code
            try:
                # Try activating rlcompleter, because it's handy.
                import readline
            except ImportError:
                pass
            else:
                # We don't have to wrap the following import in a 'try',
                # because we already know 'readline' was imported successfully.
                import rlcompleter
                readline.parse_and_bind("tab:complete")
            code.interact()

    def script(self, path):
        """Runs the script from the specifed path with flags set properly.
        arguments: path"""
        exec(compile(open(path).read(), path, 'exec'), locals(), globals())


class RoleCommands(object):
    """Class for managing roles."""

    def __init__(self):
        self.manager = manager.AuthManager()

    def add(self, user, role, project=None):
        """adds role to user
        if project is specified, adds project specific role
        arguments: user, role [project]"""
        self.manager.add_role(user, role, project)

    def has(self, user, role, project=None):
        """checks to see if user has role
        if project is specified, returns True if user has
        the global role and the project role
        arguments: user, role [project]"""
        print self.manager.has_role(user, role, project)

    def remove(self, user, role, project=None):
        """removes role from user
        if project is specified, removes project specific role
        arguments: user, role [project]"""
        self.manager.remove_role(user, role, project)


def _db_error(caught_exception):
    print caught_exception
    print _("The above error may show that the database has not "
            "been created.\nPlease create a database using "
            "'nova-manage db sync' before running this command.")
    exit(1)


class UserCommands(object):
    """Class for managing users."""

    @staticmethod
    def _print_export(user):
        """Print export variables to use with API."""
        print 'export EC2_ACCESS_KEY=%s' % user.access
        print 'export EC2_SECRET_KEY=%s' % user.secret

    def __init__(self):
        self.manager = manager.AuthManager()

    def admin(self, name, access=None, secret=None):
        """creates a new admin and prints exports
        arguments: name [access] [secret]"""
        try:
            user = self.manager.create_user(name, access, secret, True)
        except exception.DBError, e:
            _db_error(e)
        self._print_export(user)

    def create(self, name, access=None, secret=None):
        """creates a new user and prints exports
        arguments: name [access] [secret]"""
        try:
            user = self.manager.create_user(name, access, secret, False)
        except exception.DBError, e:
            _db_error(e)
        self._print_export(user)

    def delete(self, name):
        """deletes an existing user
        arguments: name"""
        self.manager.delete_user(name)

    def exports(self, name):
        """prints access and secrets for user in export format
        arguments: name"""
        user = self.manager.get_user(name)
        if user:
            self._print_export(user)
        else:
            print "User %s doesn't exist" % name

    def list(self):
        """lists all users
        arguments: <none>"""
        for user in self.manager.get_users():
            print user.name

    def modify(self, name, access_key, secret_key, is_admin):
        """update a users keys & admin flag
        arguments: accesskey secretkey admin
        leave any field blank to ignore it, admin should be 'T', 'F', or blank
        """
        if not is_admin:
            is_admin = None
        elif is_admin.upper()[0] == 'T':
            is_admin = True
        else:
            is_admin = False
        self.manager.modify_user(name, access_key, secret_key, is_admin)

    def revoke(self, user_id, project_id=None):
        """revoke certs for a user
        arguments: user_id [project_id]"""
        if project_id:
            crypto.revoke_certs_by_user_and_project(user_id, project_id)
        else:
            crypto.revoke_certs_by_user(user_id)


class ProjectCommands(object):
    """Class for managing projects."""

    def __init__(self):
        self.manager = manager.AuthManager()

    def add(self, project_id, user_id):
        """Adds user to project
        arguments: project_id user_id"""
        try:
            self.manager.add_to_project(user_id, project_id)
        except exception.UserNotFound as ex:
            print ex
            raise

    def create(self, name, project_manager, description=None):
        """Creates a new project
        arguments: name project_manager [description]"""
        try:
            self.manager.create_project(name, project_manager, description)
        except exception.UserNotFound as ex:
            print ex
            raise

    def modify(self, name, project_manager, description=None):
        """Modifies a project
        arguments: name project_manager [description]"""
        try:
            self.manager.modify_project(name, project_manager, description)
        except exception.UserNotFound as ex:
            print ex
            raise

    def delete(self, name):
        """Deletes an existing project
        arguments: name"""
        try:
            self.manager.delete_project(name)
        except exception.ProjectNotFound as ex:
            print ex
            raise

    def environment(self, project_id, user_id, filename='novarc'):
        """Exports environment variables to an sourcable file
        arguments: project_id user_id [filename='novarc]"""
        try:
            rc = self.manager.get_environment_rc(user_id, project_id)
        except (exception.UserNotFound, exception.ProjectNotFound) as ex:
            print ex
            raise
        with open(filename, 'w') as f:
            f.write(rc)

    def list(self, username=None):
        """Lists all projects
        arguments: [username]"""
        for project in self.manager.get_projects(username):
            print project.name

    def quota(self, project_id, key=None, value=None):
        """Set or display quotas for project
        arguments: project_id [key] [value]"""
        ctxt = context.get_admin_context()
        if key:
            try:
                db.quota_update(ctxt, project_id, key, value)
            except exception.ProjectQuotaNotFound:
                db.quota_create(ctxt, project_id, key, value)
        project_quota = quota.get_quota(ctxt, project_id)
        for key, value in project_quota.iteritems():
            print '%s: %s' % (key, value)

    def remove(self, project_id, user_id):
        """Removes user from project
        arguments: project_id user_id"""
        try:
            self.manager.remove_from_project(user_id, project_id)
        except (exception.UserNotFound, exception.ProjectNotFound) as ex:
            print ex
            raise

    def scrub(self, project_id):
        """Deletes data associated with project
        arguments: project_id"""
        ctxt = context.get_admin_context()
        network_ref = db.project_get_network(ctxt, project_id)
        db.network_disassociate(ctxt, network_ref['id'])
        groups = db.security_group_get_by_project(ctxt, project_id)
        for group in groups:
            db.security_group_destroy(ctxt, group['id'])

    def zipfile(self, project_id, user_id, filename='nova.zip'):
        """Exports credentials for project to a zip file
        arguments: project_id user_id [filename='nova.zip]"""
        try:
            zip_file = self.manager.get_credentials(user_id, project_id)
            with open(filename, 'w') as f:
                f.write(zip_file)
        except (exception.UserNotFound, exception.ProjectNotFound) as ex:
            print ex
            raise
        except db.api.NoMoreNetworks:
            print _('No more networks available. If this is a new '
                    'installation, you need\nto call something like this:\n\n'
                    '    nova-manage network create 10.0.0.0/8 10 64\n\n')
        except exception.ProcessExecutionError, e:
            print e
            print _("The above error may show that the certificate db has not "
                    "been created.\nPlease create a database by running a "
                    "nova-api server on this host.")

AccountCommands = ProjectCommands


class FixedIpCommands(object):
    """Class for managing fixed ip."""

    def list(self, host=None):
        """Lists all fixed ips (optionally by host) arguments: [host]"""
        ctxt = context.get_admin_context()

        try:
            if host is None:
                fixed_ips = db.fixed_ip_get_all(ctxt)
            else:
                fixed_ips = db.fixed_ip_get_all_by_host(ctxt, host)
        except exception.NotFound as ex:
            print "error: %s" % ex
            sys.exit(2)

        print "%-18s\t%-15s\t%-17s\t%-15s\t%s" % (_('network'),
                                                  _('IP address'),
                                                  _('MAC address'),
                                                  _('hostname'),
                                                  _('host'))
        for fixed_ip in fixed_ips:
            hostname = None
            host = None
            mac_address = None
            if fixed_ip['instance']:
                instance = fixed_ip['instance']
                hostname = instance['hostname']
                host = instance['host']
                mac_address = instance['mac_address']
            print "%-18s\t%-15s\t%-17s\t%-15s\t%s" % (
                    fixed_ip['network']['cidr'],
                    fixed_ip['address'],
                    mac_address, hostname, host)


class FloatingIpCommands(object):
    """Class for managing floating ip."""

    def create(self, host, range):
        """Creates floating ips for host by range
        arguments: host ip_range"""
        for address in IPy.IP(range):
            db.floating_ip_create(context.get_admin_context(),
                                  {'address': str(address),
                                   'host': host})

    def delete(self, ip_range):
        """Deletes floating ips by range
        arguments: range"""
        for address in IPy.IP(ip_range):
            db.floating_ip_destroy(context.get_admin_context(),
                                   str(address))

    def list(self, host=None):
        """Lists all floating ips (optionally by host)
        arguments: [host]"""
        ctxt = context.get_admin_context()
        if host is None:
            floating_ips = db.floating_ip_get_all(ctxt)
        else:
            floating_ips = db.floating_ip_get_all_by_host(ctxt, host)
        for floating_ip in floating_ips:
            instance = None
            if floating_ip['fixed_ip']:
                instance = floating_ip['fixed_ip']['instance']['ec2_id']
            print "%s\t%s\t%s" % (floating_ip['host'],
                                  floating_ip['address'],
                                  instance)


class NetworkCommands(object):
    """Class for managing networks."""

    def create(self, fixed_range=None, num_networks=None,
               network_size=None, vlan_start=None,
               vpn_start=None, fixed_range_v6=None, label='public'):
        """Creates fixed ips for host by range
        arguments: fixed_range=FLAG, [num_networks=FLAG],
                   [network_size=FLAG], [vlan_start=FLAG],
                   [vpn_start=FLAG], [fixed_range_v6=FLAG]"""
        if not fixed_range:
            msg = _('Fixed range in the form of 10.0.0.0/8 is '
                    'required to create networks.')
            print msg
            raise TypeError(msg)
        if not num_networks:
            num_networks = FLAGS.num_networks
        if not network_size:
            network_size = FLAGS.network_size
        if not vlan_start:
            vlan_start = FLAGS.vlan_start
        if not vpn_start:
            vpn_start = FLAGS.vpn_start
        if not fixed_range_v6:
            fixed_range_v6 = FLAGS.fixed_range_v6
        net_manager = utils.import_object(FLAGS.network_manager)
        try:
            net_manager.create_networks(context.get_admin_context(),
                                        cidr=fixed_range,
                                        num_networks=int(num_networks),
                                        network_size=int(network_size),
                                        vlan_start=int(vlan_start),
                                        vpn_start=int(vpn_start),
                                        cidr_v6=fixed_range_v6,
                                        label=label)
        except ValueError, e:
            print e
            raise e

    def list(self):
        """List all created networks"""
        print "%-18s\t%-15s\t%-15s\t%-15s" % (_('network'),
                                              _('netmask'),
                                              _('start address'),
                                              'DNS')
        for network in db.network_get_all(context.get_admin_context()):
            print "%-18s\t%-15s\t%-15s\t%-15s" % (network.cidr,
                                network.netmask,
                                network.dhcp_start,
                                network.dns)

    def delete(self, fixed_range):
        """Deletes a network"""
        network = db.network_get_by_cidr(context.get_admin_context(), \
                                         fixed_range)
        if network.project_id is not None:
            raise ValueError(_('Network must be disassociated from project %s'
                               ' before delete' % network.project_id))
        db.network_delete_safe(context.get_admin_context(), network.id)


class VmCommands(object):
    """Class for mangaging VM instances."""

    def list(self, host=None):
        """Show a list of all instances

        :param host: show all instance on specified host.
        :param instance: show specificed instance.
        """
        print "%-10s %-15s %-10s %-10s %-19s %-12s %-12s %-12s" \
              "  %-10s %-10s %-10s %-5s" % (
            _('instance'),
            _('node'),
            _('type'),
            _('state'),
            _('launched'),
            _('image'),
            _('kernel'),
            _('ramdisk'),
            _('project'),
            _('user'),
            _('zone'),
            _('index'))

        if host is None:
            instances = db.instance_get_all(context.get_admin_context())
        else:
            instances = db.instance_get_all_by_host(
                           context.get_admin_context(), host)

        for instance in instances:
            print "%-10s %-15s %-10s %-10s %-19s %-12s %-12s %-12s" \
                  "  %-10s %-10s %-10s %-5d" % (
                instance['hostname'],
                instance['host'],
                instance['instance_type'],
                instance['state_description'],
                instance['launched_at'],
                instance['image_id'],
                instance['kernel_id'],
                instance['ramdisk_id'],
                instance['project_id'],
                instance['user_id'],
                instance['availability_zone'],
                instance['launch_index'])

    def live_migration(self, ec2_id, dest):
        """Migrates a running instance to a new machine.

        :param ec2_id: instance id which comes from euca-describe-instance.
        :param dest: destination host name.

        """

        ctxt = context.get_admin_context()
        instance_id = ec2utils.ec2_id_to_id(ec2_id)

        if (FLAGS.connection_type != 'libvirt' or
           (FLAGS.connection_type == 'libvirt' and
            FLAGS.libvirt_type not in ['kvm', 'qemu'])):
            msg = _('Only KVM and QEmu are supported for now. Sorry!')
            raise exception.Error(msg)

        if (FLAGS.volume_driver != 'nova.volume.driver.AOEDriver' and \
            FLAGS.volume_driver != 'nova.volume.driver.ISCSIDriver'):
            msg = _("Support only AOEDriver and ISCSIDriver. Sorry!")
            raise exception.Error(msg)

        rpc.call(ctxt,
                 FLAGS.scheduler_topic,
                 {"method": "live_migration",
                  "args": {"instance_id": instance_id,
                           "dest": dest,
                           "topic": FLAGS.compute_topic}})

        print _('Migration of %s initiated.'
               'Check its progress using euca-describe-instances.') % ec2_id


class ServiceCommands(object):
    """Enable and disable running services"""

    def list(self, host=None, service=None):
        """Show a list of all running services. Filter by host & service name.
        args: [host] [service]"""
        ctxt = context.get_admin_context()
        now = datetime.datetime.utcnow()
        services = db.service_get_all(ctxt)
        if host:
            services = [s for s in services if s['host'] == host]
        if service:
            services = [s for s in services if s['binary'] == service]
        for svc in services:
            delta = now - (svc['updated_at'] or svc['created_at'])
            alive = (delta.seconds <= 15)
            art = (alive and ":-)") or "XXX"
            active = 'enabled'
            if svc['disabled']:
                active = 'disabled'
            print "%-10s %-10s %-8s %s %s" % (svc['host'], svc['binary'],
                                              active, art,
                                              svc['updated_at'])

    def enable(self, host, service):
        """Enable scheduling for a service
        args: host service"""
        ctxt = context.get_admin_context()
        svc = db.service_get_by_args(ctxt, host, service)
        if not svc:
            print "Unable to find service"
            return
        db.service_update(ctxt, svc['id'], {'disabled': False})

    def disable(self, host, service):
        """Disable scheduling for a service
        args: host service"""
        ctxt = context.get_admin_context()
        svc = db.service_get_by_args(ctxt, host, service)
        if not svc:
            print "Unable to find service"
            return
        db.service_update(ctxt, svc['id'], {'disabled': True})

    def describe_resource(self, host):
        """Describes cpu/memory/hdd info for host.

        :param host: hostname.

        """

        result = rpc.call(context.get_admin_context(),
                     FLAGS.scheduler_topic,
                     {"method": "show_host_resources",
                      "args": {"host": host}})

        if type(result) != dict:
            print _('An unexpected error has occurred.')
            print _('[Result]'), result
        else:
            cpu = result['resource']['vcpus']
            mem = result['resource']['memory_mb']
            hdd = result['resource']['local_gb']
            cpu_u = result['resource']['vcpus_used']
            mem_u = result['resource']['memory_mb_used']
            hdd_u = result['resource']['local_gb_used']

            print 'HOST\t\t\tPROJECT\t\tcpu\tmem(mb)\tdisk(gb)'
            print '%s(total)\t\t\t%s\t%s\t%s' % (host, cpu, mem, hdd)
            print '%s(used)\t\t\t%s\t%s\t%s' % (host, cpu_u, mem_u, hdd_u)
            for p_id, val in result['usage'].items():
                print '%s\t\t%s\t\t%s\t%s\t%s' % (host,
                                                  p_id,
                                                  val['vcpus'],
                                                  val['memory_mb'],
                                                  val['local_gb'])

    def update_resource(self, host):
        """Updates available vcpu/memory/disk info for host.

        :param host: hostname.

        """

        ctxt = context.get_admin_context()
        service_refs = db.service_get_all_by_host(ctxt, host)
        if len(service_refs) <= 0:
            raise exception.Invalid(_('%s does not exist.') % host)

        service_refs = [s for s in service_refs if s['topic'] == 'compute']
        if len(service_refs) <= 0:
            raise exception.Invalid(_('%s is not compute node.') % host)

        rpc.call(ctxt,
                 db.queue_get_for(ctxt, FLAGS.compute_topic, host),
                 {"method": "update_available_resource"})


class DbCommands(object):
    """Class for managing the database."""

    def __init__(self):
        pass

    def sync(self, version=None):
        """Sync the database up to the most recent version."""
        return migration.db_sync(version)

    def version(self):
        """Print the current database version."""
        print migration.db_version()


class VersionCommands(object):
    """Class for exposing the codebase version."""

    def __init__(self):
        pass

    def list(self):
        print _("%s (%s)") %\
                (version.version_string(), version.version_string_with_vcs())


class VolumeCommands(object):
    """Methods for dealing with a cloud in an odd state"""

    def delete(self, volume_id):
        """Delete a volume, bypassing the check that it
        must be available.
        args: volume_id_id"""
        ctxt = context.get_admin_context()
        volume = db.volume_get(ctxt, param2id(volume_id))
        host = volume['host']

        if not host:
            print "Volume not yet assigned to host."
            print "Deleting volume from database and skipping rpc."
            db.volume_destroy(ctxt, param2id(volume_id))
            return

        if volume['status'] == 'in-use':
            print "Volume is in-use."
            print "Detach volume from instance and then try again."
            return

        rpc.cast(ctxt,
                 db.queue_get_for(ctxt, FLAGS.volume_topic, host),
                 {"method": "delete_volume",
                  "args": {"volume_id": volume['id']}})

    def reattach(self, volume_id):
        """Re-attach a volume that has previously been attached
        to an instance.  Typically called after a compute host
        has been rebooted.
        args: volume_id_id"""
        ctxt = context.get_admin_context()
        volume = db.volume_get(ctxt, param2id(volume_id))
        if not volume['instance_id']:
            print "volume is not attached to an instance"
            return
        instance = db.instance_get(ctxt, volume['instance_id'])
        host = instance['host']
        rpc.cast(ctxt,
                 db.queue_get_for(ctxt, FLAGS.compute_topic, host),
                 {"method": "attach_volume",
                  "args": {"instance_id": instance['id'],
                           "volume_id": volume['id'],
                           "mountpoint": volume['mountpoint']}})


class InstanceTypeCommands(object):
    """Class for managing instance types / flavors."""

    def _print_instance_types(self, name, val):
        deleted = ('', ', inactive')[val["deleted"] == 1]
        print ("%s: Memory: %sMB, VCPUS: %s, Storage: %sGB, FlavorID: %s, "
            "Swap: %sGB, RXTX Quota: %sGB, RXTX Cap: %sMB%s") % (
            name, val["memory_mb"], val["vcpus"], val["local_gb"],
            val["flavorid"], val["swap"], val["rxtx_quota"],
            val["rxtx_cap"], deleted)

    def create(self, name, memory, vcpus, local_gb, flavorid,
               swap=0, rxtx_quota=0, rxtx_cap=0):
        """Creates instance types / flavors
           arguments: name memory vcpus local_gb flavorid [swap] [rxtx_quota]
                      [rxtx_cap]
        """
        try:
            instance_types.create(name, memory, vcpus, local_gb,
                                  flavorid, swap, rxtx_quota, rxtx_cap)
        except exception.InvalidInputException:
            print "Must supply valid parameters to create instance_type"
            print e
            sys.exit(1)
        except exception.ApiError, e:
            print "\n\n"
            print "\n%s" % e
            print "Please ensure instance_type name and flavorid are unique."
            print "To complete remove a instance_type, use the --purge flag:"
            print "\n     # nova-manage instance_type delete <name> --purge\n"
            print "Currently defined instance_type names and flavorids:"
            self.list("--all")
            sys.exit(2)
        except:
            print "Unknown error"
            sys.exit(3)
        else:
            print "%s created" % name

    def delete(self, name, purge=None):
        """Marks instance types / flavors as deleted
        arguments: name"""
        try:
            if purge == "--purge":
                instance_types.purge(name)
                verb = "purged"
            else:
                instance_types.destroy(name)
                verb = "deleted"
        except exception.ApiError:
            print "Valid instance type name is required"
            sys.exit(1)
        except exception.DBError, e:
            print "DB Error: %s" % e
            sys.exit(2)
        except:
            sys.exit(3)
        else:
            print "%s %s" % (name, verb)

    def list(self, name=None):
        """Lists all active or specific instance types / flavors
        arguments: [name]"""
        try:
            if name is None:
                inst_types = instance_types.get_all_types()
            elif name == "--all":
                inst_types = instance_types.get_all_types(True)
            else:
                inst_types = instance_types.get_instance_type_by_name(name)
        except exception.DBError, e:
            _db_error(e)
        if isinstance(inst_types.values()[0], dict):
            for k, v in inst_types.iteritems():
                self._print_instance_types(k, v)
        else:
            self._print_instance_types(name, inst_types)


class ImageCommands(object):
    """Methods for dealing with a cloud in an odd state"""

    def __init__(self, *args, **kwargs):
        self.image_service = utils.import_object(FLAGS.image_service)

    def _register(self, container_format, disk_format,
                  path, owner, name=None, is_public='T',
                  architecture='x86_64', kernel_id=None, ramdisk_id=None):
        meta = {'is_public': (is_public == 'T'),
                'name': name,
                'container_format': container_format,
                'disk_format': disk_format,
                'properties': {'image_state': 'available',
                               'project_id': owner,
                               'architecture': architecture,
                               'image_location': 'local'}}
        if kernel_id:
            meta['properties']['kernel_id'] = int(kernel_id)
        if ramdisk_id:
            meta['properties']['ramdisk_id'] = int(ramdisk_id)
        elevated = context.get_admin_context()
        try:
            with open(path) as ifile:
                image = self.image_service.create(elevated, meta, ifile)
            new = image['id']
            print _("Image registered to %(new)s (%(new)08x).") % locals()
            return new
        except Exception as exc:
            print _("Failed to register %(path)s: %(exc)s") % locals()

    def all_register(self, image, kernel, ramdisk, owner, name=None,
                 is_public='T', architecture='x86_64'):
        """Uploads an image, kernel, and ramdisk into the image_service
        arguments: image kernel ramdisk owner [name] [is_public='T']
                   [architecture='x86_64']"""
        kernel_id = self.kernel_register(kernel, owner, None,
                                   is_public, architecture)
        ramdisk_id = self.ramdisk_register(ramdisk, owner, None,
                                    is_public, architecture)
        self.image_register(image, owner, name, is_public,
                            architecture, 'ami', 'ami',
                            kernel_id, ramdisk_id)

    def image_register(self, path, owner, name=None, is_public='T',
                       architecture='x86_64', container_format='bare',
                       disk_format='raw', kernel_id=None, ramdisk_id=None):
        """Uploads an image into the image_service
        arguments: path owner [name] [is_public='T'] [architecture='x86_64']
                   [container_format='bare'] [disk_format='raw']
                   [kernel_id=None] [ramdisk_id=None]
        """
        return self._register(container_format, disk_format, path,
                              owner, name, is_public, architecture,
                              kernel_id, ramdisk_id)

    def kernel_register(self, path, owner, name=None, is_public='T',
               architecture='x86_64'):
        """Uploads a kernel into the image_service
        arguments: path owner [name] [is_public='T'] [architecture='x86_64']
        """
        return self._register('aki', 'aki', path, owner, name,
                              is_public, architecture)

    def ramdisk_register(self, path, owner, name=None, is_public='T',
                architecture='x86_64'):
        """Uploads a ramdisk into the image_service
        arguments: path owner [name] [is_public='T'] [architecture='x86_64']
        """
        return self._register('ari', 'ari', path, owner, name,
                              is_public, architecture)

    def _lookup(self, old_image_id):
        try:
            internal_id = ec2utils.ec2_id_to_id(old_image_id)
            image = self.image_service.show(context, internal_id)
        except (exception.InvalidEc2Id, exception.ImageNotFound):
            image = self.image_service.show_by_name(context, old_image_id)
        return image['id']

    def _old_to_new(self, old):
        mapping = {'machine': 'ami',
                   'kernel': 'aki',
                   'ramdisk': 'ari'}
        container_format = mapping[old['type']]
        disk_format = container_format
        if container_format == 'ami' and not old.get('kernelId'):
            container_format = 'bare'
            disk_format = 'raw'
        new = {'disk_format': disk_format,
               'container_format': container_format,
               'is_public': old['isPublic'],
               'name': old['imageId'],
               'properties': {'image_state': old['imageState'],
                              'project_id': old['imageOwnerId'],
                              'architecture': old['architecture'],
                              'image_location': old['imageLocation']}}
        if old.get('kernelId'):
            new['properties']['kernel_id'] = self._lookup(old['kernelId'])
        if old.get('ramdiskId'):
            new['properties']['ramdisk_id'] = self._lookup(old['ramdiskId'])
        return new

    def _convert_images(self, images):
        elevated = context.get_admin_context()
        for image_path, image_metadata in images.iteritems():
            meta = self._old_to_new(image_metadata)
            old = meta['name']
            try:
                with open(image_path) as ifile:
                    image = self.image_service.create(elevated, meta, ifile)
                new = image['id']
                print _("Image %(old)s converted to " \
                        "%(new)s (%(new)08x).") % locals()
            except Exception as exc:
                print _("Failed to convert %(old)s: %(exc)s") % locals()

    def convert(self, directory):
        """Uploads old objectstore images in directory to new service
        arguments: directory"""
        machine_images = {}
        other_images = {}
        directory = os.path.abspath(directory)
        # NOTE(vish): If we're importing from the images path dir, attempt
        #             to move the files out of the way before importing
        #             so we aren't writing to the same directory. This
        #             may fail if the dir was a mointpoint.
        if (FLAGS.image_service == 'nova.image.local.LocalImageService'
            and directory == os.path.abspath(FLAGS.images_path)):
            new_dir = "%s_bak" % directory
            os.rename(directory, new_dir)
            os.mkdir(directory)
            directory = new_dir
        for fn in glob.glob("%s/*/info.json" % directory):
            try:
                image_path = os.path.join(fn.rpartition('/')[0], 'image')
                with open(fn) as metadata_file:
                    image_metadata = json.load(metadata_file)
                if image_metadata['type'] == 'machine':
                    machine_images[image_path] = image_metadata
                else:
                    other_images[image_path] = image_metadata
            except Exception:
                print _("Failed to load %(fn)s.") % locals()
        # NOTE(vish): do kernels and ramdisks first so images
        self._convert_images(other_images)
        self._convert_images(machine_images)


CATEGORIES = [
    ('user', UserCommands),
    ('account', AccountCommands),
    ('project', ProjectCommands),
    ('role', RoleCommands),
    ('shell', ShellCommands),
    ('vpn', VpnCommands),
    ('fixed', FixedIpCommands),
    ('floating', FloatingIpCommands),
    ('network', NetworkCommands),
    ('vm', VmCommands),
    ('service', ServiceCommands),
    ('db', DbCommands),
    ('volume', VolumeCommands),
    ('instance_type', InstanceTypeCommands),
    ('image', ImageCommands),
    ('flavor', InstanceTypeCommands),
    ('version', VersionCommands)]


def lazy_match(name, key_value_tuples):
    """Finds all objects that have a key that case insensitively contains
    [name] key_value_tuples is a list of tuples of the form (key, value)
    returns a list of tuples of the form (key, value)"""
    result = []
    for (k, v) in key_value_tuples:
        if k.lower().find(name.lower()) == 0:
            result.append((k, v))
    if len(result) == 0:
        print "%s does not match any options:" % name
        for k, _v in key_value_tuples:
            print "\t%s" % k
        sys.exit(2)
    if len(result) > 1:
        print "%s matched multiple options:" % name
        for k, _v in result:
            print "\t%s" % k
        sys.exit(2)
    return result


def methods_of(obj):
    """Get all callable methods of an object that don't start with underscore
    returns a list of tuples of the form (method_name, method)"""
    result = []
    for i in dir(obj):
        if callable(getattr(obj, i)) and not i.startswith('_'):
            result.append((i, getattr(obj, i)))
    return result


def main():
    """Parse options and call the appropriate class/method."""
    utils.default_flagfile()
    argv = FLAGS(sys.argv)
    logging.setup()

    script_name = argv.pop(0)
    if len(argv) < 1:
        print _("\nOpenStack Nova version: %s (%s)\n") %\
                (version.version_string(), version.version_string_with_vcs())
        print script_name + " category action [<args>]"
        print _("Available categories:")
        for k, _v in CATEGORIES:
            print "\t%s" % k
        sys.exit(2)
    category = argv.pop(0)
    matches = lazy_match(category, CATEGORIES)
    # instantiate the command group object
    category, fn = matches[0]
    command_object = fn()
    actions = methods_of(command_object)
    if len(argv) < 1:
        print script_name + " category action [<args>]"
        print _("Available actions for %s category:") % category
        for k, _v in actions:
            print "\t%s" % k
        sys.exit(2)
    action = argv.pop(0)
    matches = lazy_match(action, actions)
    action, fn = matches[0]
    # call the action with the remaining arguments
    try:
        fn(*argv)
        sys.exit(0)
    except TypeError:
        print _("Possible wrong number of arguments supplied")
        print "%s %s: %s" % (category, action, fn.__doc__)
        raise
    except Exception:
        print _("Command failed, please check log for more info")
        raise

if __name__ == '__main__':
    main()
